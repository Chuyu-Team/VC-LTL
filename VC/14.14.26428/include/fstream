// fstream standard header
#pragma once
#ifndef _FSTREAM_
#define _FSTREAM_
#ifndef RC_INVOKED
#include <istream>

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 _STL_DISABLE_CLANG_WARNINGS
 #pragma push_macro("new")
 #undef new

// The _Path_ish functions accepting filesystem::path or experimental::filesystem::path are templates which
// always use the same types as a workaround for user code deriving from iostreams types and
// __declspec(dllexport)ing the derived types. Adding member functions to iostreams broke the ABI of such DLLs.
// Deriving and __declspec(dllexport)ing standard library types is not supported, but in this particular case
// the workaround was inexpensive. The workaround will be removed in the next ABI breaking release of the
// Visual C++ Libraries.
_STD_BEGIN
#if _HAS_CXX17
namespace filesystem
{
class path;
}
#endif /* _HAS_CXX17 */

namespace experimental
{
namespace filesystem
{
inline namespace v1
{
class path;
}}}	// experimental::filesystem::v1

extern _CRTIMP2_PURE _Filet *__CLRCALL_PURE_OR_CDECL _Fiopen(
	const char *,
	ios_base::openmode, int);
extern _CRTIMP2_PURE _Filet *__CLRCALL_PURE_OR_CDECL _Fiopen(
	const wchar_t *,
	ios_base::openmode, int);

 #ifdef _NATIVE_WCHAR_T_DEFINED
extern _CRTIMP2_PURE _Filet *__CLRCALL_PURE_OR_CDECL _Fiopen(
	const unsigned short *,
	ios_base::openmode, int);
 #endif /* _NATIVE_WCHAR_T_DEFINED */

		// FUNCTION TEMPLATE _Fgetc
template<class _Elem> inline
	bool _Fgetc(_Elem& _Ch, _Filet *_File)
	{	// get an element from a C stream
	return (fread(&_Ch, sizeof (_Elem), 1, _File) == 1);
	}

template<> inline bool _Fgetc(char& _Byte, _Filet *_File)
	{	// get a char element from a C stream
	int _Meta;
	if ((_Meta = fgetc(_File)) == EOF)
		return (false);
	else
		{	// got one, convert to char
		_Byte = (char)_Meta;
		return (true);
		}
	}

template<> inline bool _Fgetc(wchar_t& _Wchar, _Filet *_File)
	{	// get a wchar_t element from a C stream
	wint_t _Meta;
	if ((_Meta = _CSTD fgetwc(_File)) == WEOF)
		return (false);
	else
		{	// got one, convert to wchar_t
		_Wchar = (wchar_t)_Meta;
		return (true);
		}
	}

 #ifdef _NATIVE_WCHAR_T_DEFINED
template<> inline bool _Fgetc(unsigned short& _Wchar, _Filet *_File)
	{	// get an unsigned short element from a C stream
	wint_t _Meta;
	if ((_Meta = _CSTD fgetwc(_File)) == WEOF)
		return (false);
	else
		{	// got one, convert to unsigned short
		_Wchar = (unsigned short)_Meta;
		return (true);
		}
	}
 #endif /* _NATIVE_WCHAR_T_DEFINED */

		// FUNCTION TEMPLATE _Fputc
template<class _Elem> inline
	bool _Fputc(_Elem _Ch, _Filet *_File)
	{	// put an element to a C stream
	return (fwrite(&_Ch, 1, sizeof (_Elem), _File) == sizeof (_Elem));
	}

template<> inline bool _Fputc(char _Byte, _Filet *_File)
	{	// put a char element to a C stream
	return (fputc(_Byte, _File) != EOF);
	}

template<> inline bool _Fputc(wchar_t _Wchar, _Filet *_File)
	{	// put a wchar_t element to a C stream
	return (_CSTD fputwc(_Wchar, _File) != WEOF);
	}

 #ifdef _NATIVE_WCHAR_T_DEFINED
template<> inline bool _Fputc(unsigned short _Wchar, _Filet *_File)
	{	// put an unsigned short element to a C stream
	return (_CSTD fputwc(_Wchar, _File) != WEOF);
	}
 #endif /* _NATIVE_WCHAR_T_DEFINED */

		// FUNCTION TEMPLATE _Ungetc
template<class _Elem> inline
	bool _Ungetc(const _Elem&, _Filet *)
	{	// put back an arbitrary element to a C stream (always fail)
	return (false);
	}

template<> inline bool _Ungetc(const char& _Byte, _Filet *_File)
	{	// put back a char element to a C stream
	return (ungetc((unsigned char)_Byte, _File) != EOF);
	}

template<> inline bool _Ungetc(const signed char& _Byte, _Filet *_File)
	{	// put back a signed char element to a C stream
	return (ungetc((unsigned char)_Byte, _File) != EOF);
	}

template<> inline bool _Ungetc(const unsigned char& _Byte, _Filet *_File)
	{	// put back an unsigned char element to a C stream
	return (ungetc(_Byte, _File) != EOF);
	}

template<> inline bool _Ungetc(const wchar_t& _Wchar, _Filet *_File)
	{	// put back a wchar_t element to a C stream
	return (_CSTD ungetwc(_Wchar, _File) != WEOF);
	}

 #ifdef _NATIVE_WCHAR_T_DEFINED
template<> inline bool _Ungetc(const unsigned short& _Wchar, _Filet *_File)
	{	// put back an unsigned short element to a C stream
	return (_CSTD ungetwc(_Wchar, _File) != WEOF);
	}
 #endif /* _NATIVE_WCHAR_T_DEFINED */

		// CLASS TEMPLATE basic_filebuf
template<class _Elem,
	class _Traits>
	class basic_filebuf
		: public basic_streambuf<_Elem, _Traits>
	{	// stream buffer associated with a C stream
public:
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef typename _Traits::state_type _Myst;
	typedef codecvt<_Elem, char, typename _Traits::state_type> _Cvt;

	basic_filebuf(_Filet *_File = 0)
		: _Mysb()
		{	// construct from pointer to C stream
		_Init(_File, _Newfl);
		}

	virtual __CLR_OR_THIS_CALL ~basic_filebuf() _NOEXCEPT
		{	// destroy the object
		if (_Myfile != 0)
			_Reset_back();	// revert from _Mychar buffer
		if (_Closef)
			close();
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	basic_filebuf(_Uninitialized)
		: _Mysb(_Noinit)
		{	// construct uninitialized
		}

	basic_filebuf(basic_filebuf&& _Right)
		{	// construct by copying _Right
		_Init(_Right._Myfile, _Newfl);	// match buffering styles
		_Init((_Filet *)0, _Closefl);	// then make *this look closed
		_Assign_rv(_STD move(_Right));
		}

	basic_filebuf& operator=(basic_filebuf&& _Right)
		{	// assign from _Right
		_Assign_rv(_STD move(_Right));
		return (*this);
		}

	void _Assign_rv(basic_filebuf&& _Right)
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, worth moving
			close();
			this->swap(_Right);
			}
		}

	void swap(basic_filebuf& _Right)
		{	// swap with _Right
		if (this != _STD addressof(_Right))
			{	// different, worth swapping
			// save values altered by _Init
			_Filet *_Myfile_sav = _Myfile;
			const _Cvt *_Pcvt_sav = _Pcvt;
			typename _Traits::state_type _State_sav = _State;
			bool _Wrotesome_sav = _Wrotesome;
			bool _Closef_sav = _Closef;
			bool _Set_eback_sav = _Mysb::eback() == &_Mychar;
			bool _Set_eback_live = _Mysb::gptr() == &_Mychar;

			_Elem *_Pfirst0 = _Mysb::pbase();
			_Elem *_Pnext0 = _Mysb::pptr();
			_Elem *_Pend = _Mysb::epptr();
			_Elem *_Gfirst0 = _Mysb::eback();
			_Elem *_Gnext0 = _Mysb::gptr();
			_Elem *_Gend = _Mysb::egptr();

			// reinitialize *this
			_Init(_Right._Myfile, _Right._Myfile != 0 ? _Openfl : _Newfl);
			_Mysb::setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			if (_Right.eback() != &_Right._Mychar)
				_Mysb::setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			else if (_Right.gptr() != &_Right._Mychar)
				_Mysb::setg(&_Mychar, &_Mychar + 1, &_Mychar + 1);
			else
				_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

			_Pcvt = _Right._Pcvt;
			_State = _Right._State;
			_Wrotesome = _Right._Wrotesome;
			_Closef = _Right._Closef;

			// reinitialize _Right
			_Right._Init(_Myfile_sav, _Myfile_sav != 0 ? _Openfl : _Newfl);
			_Right.setp(_Pfirst0, _Pnext0, _Pend);
			if (!_Set_eback_sav)
				_Right.setg(_Gfirst0, _Gnext0, _Gend);
			else if (!_Set_eback_live)
				_Right.setg(&_Right._Mychar, &_Right._Mychar + 1,
					&_Right._Mychar + 1);
			else
				_Right.setg(&_Right._Mychar, &_Right._Mychar,
					&_Right._Mychar + 1);

			_Right._Pcvt = _Pcvt_sav;
			_Right._State = _State_sav;
			_Right._Wrotesome = _Wrotesome_sav;
			_Right._Closef = _Closef_sav;

			// swap ancillary data
			_STD swap(_Set_eback, _Right._Set_eback);
			_STD swap(_Set_egptr, _Right._Set_egptr);

			_STD swap(_Mychar, _Right._Mychar);
			_STD swap(_Mysb::_Plocale, _Right._Plocale);
			}
		}

	basic_filebuf(const basic_filebuf&) = delete;
	basic_filebuf& operator=(const basic_filebuf&) = delete;

	enum _Initfl
		{	// reasons for a call to _Init
		_Newfl, _Openfl, _Closefl};

	_NODISCARD bool is_open() const
		{	// test if C stream has been opened
		return (_Myfile != 0);
		}

	basic_filebuf *open(const char *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a C stream with specified mode
		_Filet *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	// open failed

		_Init(_File, _Openfl);
		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));
		return (this);	// open succeeded
		}

	basic_filebuf *open(const string& _Str,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a C stream with specified mode
		return (open(_Str.c_str(), _Mode, _Prot));
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	basic_filebuf *open(const char *_Filename, ios_base::open_mode _Mode)
		{	// open a C stream with specified mode (old style)
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */

	basic_filebuf *open(const wchar_t *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
		_Filet *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	// open failed

		_Init(_File, _Openfl);
		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));
		return (this);	// open succeeded
		}

	basic_filebuf *open(const wstring& _Str,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream -- EXTENSION
		return (open(_Str.c_str(), _Mode, _Prot));
		}

	template<class _Path_ish = experimental::filesystem::path>
		basic_filebuf *open(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a path-named C stream
		return (open(_Path.c_str(), _Mode, _Prot));
		}

 #if _HAS_CXX17
	template<int = 0,
		class _Path_ish = filesystem::path>
		basic_filebuf *open(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a path-named C stream
		return (open(_Path.c_str(), _Mode, _Prot));
		}
 #endif /* _HAS_CXX17 */

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	basic_filebuf *open(const wchar_t *_Filename,
		ios_base::open_mode _Mode)
		{	// open a wide-named C stream (old style) (in standard as const std::filesystem::path::value_type *)
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */

 #ifdef _NATIVE_WCHAR_T_DEFINED
	basic_filebuf *open(const unsigned short *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
		_Filet *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	// open failed

		_Init(_File, _Openfl);
		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));
		return (this);	// open succeeded
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	basic_filebuf *open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	// open a wide-named C stream (old style) (in standard as const std::filesystem::path::value_type *)
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
 #endif /* _NATIVE_WCHAR_T_DEFINED */

	basic_filebuf *close()
		{	// close the C stream
		basic_filebuf *_Ans = this;
		if (_Myfile == 0)
			_Ans = 0;
		else
			{	// put any homing sequence and close file
			if (!_Endwrite())
				_Ans = 0;
			if (fclose(_Myfile) != 0)
				_Ans = 0;
			}
		_Init(0, _Closefl);
		return (_Ans);
		}

	virtual void __CLR_OR_THIS_CALL _Lock()
		{	// lock file instead of stream buffer
		if (_Myfile)
			_CSTD _lock_file(_Myfile);
		}

	virtual void __CLR_OR_THIS_CALL _Unlock()
		{	// unlock file instead of stream buffer
		if (_Myfile)
			_CSTD _unlock_file(_Myfile);
		}

protected:
	virtual int_type __CLR_OR_THIS_CALL overflow(int_type _Meta =
		_Traits::eof())
		{	// put an element to stream
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			{
			return (_Traits::not_eof(_Meta));	// EOF, return success code
			}
		else if (_Mysb::pptr() != 0 && _Mysb::pptr() < _Mysb::epptr())
			{	// room in buffer, store it
			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		else if (_Myfile == 0)
			{
			return (_Traits::eof());	// no open C stream, fail
			}

		_Reset_back();	// revert from _Mychar buffer
		if (_Pcvt == 0)
			{
			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
				? _Meta : _Traits::eof());	// no codecvt facet, put as is
			}
		else
			{	// put using codecvt facet
			const int _STRING_INC = 8;
			const _Elem _Ch = _Traits::to_char_type(_Meta);
			const _Elem *_Src;
			char *_Dest;

			string _Str(_STRING_INC, '\0');
			for (;;)
				{
				switch (_Pcvt->out(_State,
					&_Ch, &_Ch + 1, _Src,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
					{	// test result of converting one element
					case codecvt_base::partial:
					case codecvt_base::ok:
						{	// converted something, try to put it out
						size_t _Count = _Dest - &*_Str.begin();
						if (0 < _Count && _Count !=
							fwrite(&*_Str.begin(), 1, _Count, _Myfile))
							return (_Traits::eof());	// write failed

						_Wrotesome = true;	// write succeeded
						if (_Src != &_Ch)
							return (_Meta);	// converted whole element

						if (0 < _Count)
							;
						else if (_Str.size() < 4 * _STRING_INC)
							_Str.append(_STRING_INC, '\0');	// try with more space
						else
							return (_Traits::eof());	// conversion failed
						break;
						}

					case codecvt_base::noconv:
						return (_Fputc(_Ch, _Myfile) ? _Meta
							: _Traits::eof());	// no conversion, put as is

					default:
						return (_Traits::eof());	// conversion failed
					}
				}
			}
		}

	virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta =
		_Traits::eof())
		{	// put an element back to stream
		if (_Mysb::gptr() != 0
			&& _Mysb::eback() < _Mysb::gptr()
			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
				_Meta)))
			{	// just back up position
			_Mysb::_Gndec();
			return (_Traits::not_eof(_Meta));
			}
		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::eof());	// no open C stream or EOF, fail
		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))
			return (_Meta);	// no facet and unget succeeded, return
		else if (_Mysb::gptr() != &_Mychar)
			{	// putback to _Mychar
			_Mychar = _Traits::to_char_type(_Meta);
			_Set_back();	// switch to _Mychar buffer
			return (_Meta);
			}
		else
			return (_Traits::eof());	// nowhere to put back
	}

	virtual int_type __CLR_OR_THIS_CALL underflow()
		{	// get an element from stream, but don't point past it
		int_type _Meta;
		if (_Mysb::gptr() != 0
			&& _Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered
		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
			return (_Meta);	// uflow failed, return EOF
		else
			{	// get a char, don't point past it
			pbackfail(_Meta);
			return (_Meta);
			}
		}

	virtual int_type __CLR_OR_THIS_CALL uflow()
		{	// get an element from stream, point past it
		if (_Mysb::gptr() != 0
			&& _Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(
				*_Mysb::_Gninc()));	// return buffered
		else if (_Myfile == 0)
			return (_Traits::eof());	// no open C stream, fail
		_Reset_back();	// revert from _Mychar buffer
		if (_Pcvt == 0)
			{	// no codecvt facet, just get it
			_Elem _Ch = 0;
			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
				: _Traits::eof());
			}
		else
			{	// build string until codecvt succeeds
			string _Str;

			for (;;)
				{	// get using codecvt facet
				_Elem _Ch, *_Dest;
				const char *_Src;
				int _Nleft;
				int _Meta = fgetc(_Myfile);

				if (_Meta == EOF)
					return (_Traits::eof());	// partial char?

				_Str.append(1, (char)_Meta);	// append byte and convert
				switch (_Pcvt->in(_State,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
					&_Ch, &_Ch + 1, _Dest))
					{	// test result of converting one element
				case codecvt_base::partial:
				case codecvt_base::ok:
					if (_Dest != &_Ch)
						{	// got an element, put back excess and deliver it
						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);
						while (0 < _Nleft)
							{
							ungetc(_Src[--_Nleft], _Myfile);
							}

						return (_Traits::to_int_type(_Ch));
						}
					else
						_Str.erase((size_t)0,	// partial, discard used input
							(size_t)(_Src - &*_Str.begin()));
					break;

				case codecvt_base::noconv:
					if (_Str.size() < sizeof (_Elem))
						break;	// no conversion, but need more chars

					_CRT_SECURE_MEMCPY(&_Ch, sizeof (_Elem), &*_Str.begin(),
						sizeof (_Elem));	// copy raw bytes to element

					return (_Traits::to_int_type(_Ch));	// return result

				default:
					return (_Traits::eof());	// conversion failed
					}
				}
			}
		}

	virtual pos_type __CLR_OR_THIS_CALL seekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{	// change position by _Off
		fpos_t _Fileposition;

		if (_Mysb::gptr() == &_Mychar	// something putback
			&& _Way == ios_base::cur	// a relative seek
			&& _Pcvt == 0)	// not converting
			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

		if (_Myfile == 0 || !_Endwrite()
			|| ((_Off != 0 || _Way != ios_base::cur)
				&& _fseeki64(_Myfile, _Off, _Way) != 0)
			|| fgetpos(_Myfile, &_Fileposition) != 0)
			return (pos_type(_BADOFF));	// report failure

		_Reset_back();	// revert from _Mychar buffer, discarding any putback
		return (_POS_TYPE_FROM_STATE(pos_type, _State,
			_Fileposition));	// return new position
		}

	virtual pos_type __CLR_OR_THIS_CALL seekpos(pos_type _Pos,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{	// change position to _Pos
		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);
		off_type _Off = static_cast<off_type>(_Pos) - static_cast<off_type>(_Fileposition);

		if (_Myfile == 0 || !_Endwrite()
			|| fsetpos(_Myfile, &_Fileposition) != 0
			|| (_Off != 0 && _fseeki64(_Myfile, _Off, SEEK_CUR) != 0)
			|| fgetpos(_Myfile, &_Fileposition) != 0)
			return (pos_type(_BADOFF));	// report failure

		_State = _POS_TYPE_TO_STATE(_Pos);

		_Reset_back();	// revert from _Mychar buffer, discarding any putback
		return (_POS_TYPE_FROM_STATE(pos_type, _State,
			_Fileposition));	// return new position
		}

	virtual _Mysb *__CLR_OR_THIS_CALL setbuf(_Elem *_Buffer, streamsize _Count)
		{	// offer _Buffer to C stream
		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
			(size_t)_Count * sizeof (_Elem)) != 0)
			return (0);	// failed
		else
			{	// new buffer, reinitialize pointers
			_Init(_Myfile, _Openfl);
			return (this);
			}
		}

	virtual int __CLR_OR_THIS_CALL sync()
		{	// synchronize C stream with external file
		return (_Myfile == 0
			|| _Traits::eq_int_type(_Traits::eof(), overflow())
			|| 0 <= fflush(_Myfile) ? 0 : -1);
		}

	virtual void __CLR_OR_THIS_CALL imbue(const locale& _Loc)
		{	// set locale to argument (capture nontrivial codecvt facet)
		_Initcvt(_STD use_facet<_Cvt>(_Loc));
		}

	void _Init(_Filet *_File, _Initfl _Which)
		{	// initialize to C stream _File after {new, open, close}
		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state

		_Closef = _Which == _Openfl;
		_Wrotesome = false;

		_Mysb::_Init();	// initialize stream buffer base object

		if (_File != 0 && sizeof (_Elem) == 1)
			{	// point inside C stream with [first, first + count) buffer
			_Elem **_Pb = 0;
			_Elem **_Pn = 0;
			int *_Nr = 0;

			::_get_stream_buffer_pointers(
				_File,
				reinterpret_cast<char***>(&_Pb),
				reinterpret_cast<char***>(&_Pn),
				&_Nr);
			int *_Nw = _Nr;

			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
			}

		_Myfile = _File;
		_State = _Stinit;
		_Pcvt = 0;	// pointer to codecvt facet
		}

	bool _Endwrite()
		{	// put shift to initial conversion state, as needed
		if (_Pcvt == 0 || !_Wrotesome)
			return (true);
		else
			{	// may have to put
			const int _STRING_INC = 8;
			char *_Dest;
			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
				return (false);

			string _Str(_STRING_INC, '\0');
			for (;;)
				{
				switch (_Pcvt->unshift(_State,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
					{	// test result of homing conversion
					case codecvt_base::ok:
						_Wrotesome = false;	// homed successfully

					case codecvt_base::partial:	// fall through
						{	// put any generated bytes
						size_t _Count = _Dest - &*_Str.begin();
						if (0 < _Count && _Count !=
							fwrite(&*_Str.begin(), 1, _Count, _Myfile))
							return (false);	// write failed
						if (!_Wrotesome)
							return (true);
						if (_Count == 0)
							_Str.append(_STRING_INC, '\0');	// try with more space
						break;
						}

					case codecvt_base::noconv:
						return (true);	// nothing to do

					default:
						return (false);	// conversion failed
					}
				}
			}
		}

	void _Initcvt(const _Cvt& _Newcvt)
		{	// initialize codecvt pointer
		if (_Newcvt.always_noconv())
			_Pcvt = nullptr;	// nothing to do
		else
			{	// set up for nontrivial codecvt facet
			_Pcvt = _STD addressof(_Newcvt);
			_Mysb::_Init();	// reset any buffering
			}
		}

private:
	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
	_Elem _Mychar;	// putback character, when _Ungetc fails
	bool _Wrotesome;	// true if homing sequence may be needed
	typename _Traits::state_type _State;	// current conversion state
	bool _Closef;	// true if C stream must be closed
	_Filet *_Myfile;	// pointer to C stream

	void _Reset_back()
		{	// restore buffer after putback
		if (_Mysb::eback() == &_Mychar)
			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
		}

	void _Set_back()
		{	// set up putback area
		if (_Mysb::eback() != &_Mychar)
			{	// save current get buffer
			_Set_eback = _Mysb::eback();
			_Set_egptr = _Mysb::egptr();
			}
		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
		}

	_Elem *_Set_eback;	// saves eback() during one-element putback
	_Elem *_Set_egptr;	// saves egptr()
	};

template<class _Elem,
	class _Traits> inline
	void swap(basic_filebuf<_Elem, _Traits>& _Left,
		basic_filebuf<_Elem, _Traits>& _Right)
	{	// swap _Left and _Right basic_filebufs
	_Left.swap(_Right);
	}

		// CLASS TEMPLATE basic_ifstream
template<class _Elem,
	class _Traits>
	class basic_ifstream
		: public basic_istream<_Elem, _Traits>
	{	// input stream associated with a C stream
public:
	typedef basic_istream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;

	basic_ifstream()
		: _Mybase(&_Filebuffer)
		{	// construct unopened
		}

	explicit basic_ifstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	// construct with named file and specified mode
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
		{	// construct with named file and specified mode
		}

	explicit basic_ifstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
		{	// construct with wide-named file -- EXTENSION
		}

	template<class _Path_ish = experimental::filesystem::path>
		explicit basic_ifstream(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: basic_ifstream(_Path.c_str(), _Mode, _Prot)
		{	// construct with path-named file
		}

 #if _HAS_CXX17
	template<int = 0,
		class _Path_ish = filesystem::path>
		explicit basic_ifstream(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: basic_ifstream(_Path.c_str(), _Mode, _Prot)
		{	// construct with path-named file
		}
 #endif /* _HAS_CXX17 */

 #ifdef _NATIVE_WCHAR_T_DEFINED
	explicit basic_ifstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #endif /* _NATIVE_WCHAR_T_DEFINED */

	explicit basic_ifstream(_Filet *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	// construct with specified C stream
		}

	basic_ifstream(basic_ifstream&& _Right)
		: _Mybase(&_Filebuffer)
		{	// construct by moving _Right
		_Assign_rv(_STD move(_Right));
		}

	basic_ifstream& operator=(basic_ifstream&& _Right)
		{	// move from _Right
		_Assign_rv(_STD move(_Right));
		return (*this);
		}

	void _Assign_rv(basic_ifstream&& _Right)
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, worth moving
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(basic_ifstream& _Right)
		{	// swap with _Right
		if (this != _STD addressof(_Right))
			{	// different, swap base and buffer
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_ifstream(const basic_ifstream&) = delete;
	basic_ifstream& operator=(const basic_ifstream&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	// added with C++11
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream -- EXTENSION
		open(_Str.c_str(), _Mode, _Prot);
		}

	template<class _Path_ish = experimental::filesystem::path>
		void open(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a path-named C stream
		open(_Path.c_str(), _Mode, _Prot);
		}

 #if _HAS_CXX17
	template<int = 0,
		class _Path_ish = filesystem::path>
		void open(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a path-named C stream
		open(_Path.c_str(), _Mode, _Prot);
		}
 #endif /* _HAS_CXX17 */

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */

 #ifdef _NATIVE_WCHAR_T_DEFINED
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	// added with C++11
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
 #endif /* _NATIVE_WCHAR_T_DEFINED */

	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
		{	// destroy the object
		}

	_NODISCARD _Myfb *rdbuf() const
		{	// return pointer to file buffer
		return ((_Myfb *)&_Filebuffer);
		}

	_NODISCARD bool is_open() const
		{	// test if C stream has been opened
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a C stream with specified mode
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	// added with C++11
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a C stream with specified mode
		open(_Str.c_str(), _Mode, _Prot);
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	// open named file with specified mode (old style)
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */

	void close()
		{	// close the C stream
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
		}

private:
	_Myfb _Filebuffer;	// the file buffer
	};

template<class _Elem,
	class _Traits> inline
	void swap(basic_ifstream<_Elem, _Traits>& _Left,
		basic_ifstream<_Elem, _Traits>& _Right)
	{	// swap _Left and _Right basic_ifstreams
	_Left.swap(_Right);
	}

		// CLASS TEMPLATE basic_ofstream
template<class _Elem,
	class _Traits>
	class basic_ofstream
		: public basic_ostream<_Elem, _Traits>
	{	// output stream associated with a C stream
public:
	typedef basic_ostream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;

	basic_ofstream()
		: _Mybase(&_Filebuffer)
		{	// construct unopened
		}

	explicit basic_ofstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	// construct with named file and specified mode
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: basic_ofstream(_Str.c_str(), _Mode, _Prot)
		{	// construct with named file and specified mode
		}

	explicit basic_ofstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: basic_ofstream(_Str.c_str(), _Mode, _Prot)
		{	// construct with wide-named file -- EXTENSION
		}

	template<class _Path_ish = experimental::filesystem::path>
		explicit basic_ofstream(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: basic_ofstream(_Path.c_str(), _Mode, _Prot)
		{	// construct with path-named file
		}

 #if _HAS_CXX17
	template<int = 0,
		class _Path_ish = filesystem::path>
		explicit basic_ofstream(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: basic_ofstream(_Path.c_str(), _Mode, _Prot)
		{	// construct with path-named file
		}
 #endif /* _HAS_CXX17 */

 #ifdef _NATIVE_WCHAR_T_DEFINED
	explicit basic_ofstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #endif /* _NATIVE_WCHAR_T_DEFINED */

	explicit basic_ofstream(_Filet *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	// construct with specified C stream
		}

	basic_ofstream(basic_ofstream&& _Right)
		: _Mybase(&_Filebuffer)
		{	// construct by moving _Right
		_Assign_rv(_STD move(_Right));
		}

	basic_ofstream& operator=(basic_ofstream&& _Right)
		{	// move from _Right
		_Assign_rv(_STD move(_Right));
		return (*this);
		}

	void _Assign_rv(basic_ofstream&& _Right)
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, worth moving
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(basic_ofstream& _Right)
		{	// swap with _Right
		if (this != _STD addressof(_Right))
			{	// different, swap base and buffer
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_ofstream(const basic_ofstream&) = delete;
	basic_ofstream& operator=(const basic_ofstream&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	// added with C++11
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream -- EXTENSION
		open(_Str.c_str(), _Mode, _Prot);
		}

	template<class _Path_ish = experimental::filesystem::path>
		void open(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a path-named C stream
		open(_Path.c_str(), _Mode, _Prot);
		}

 #if _HAS_CXX17
	template<int = 0,
		class _Path_ish = filesystem::path>
		void open(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a path-named C stream
		open(_Path.c_str(), _Mode, _Prot);
		}
 #endif /* _HAS_CXX17 */

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	// open a wide-named C stream (old style) (in standard as const std::filesystem::path::value_type *)
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */

 #ifdef _NATIVE_WCHAR_T_DEFINED
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	// added with C++11
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	// open a wide-named C stream (old style) (in standard as const std::filesystem::path::value_type *)
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
 #endif /* _NATIVE_WCHAR_T_DEFINED */

	virtual __CLR_OR_THIS_CALL ~basic_ofstream() _NOEXCEPT
		{	// destroy the object
		}

	_NODISCARD _Myfb *rdbuf() const
		{	// return pointer to file buffer
		return ((_Myfb *)&_Filebuffer);
		}

	_NODISCARD bool is_open() const
		{	// test if C stream has been opened
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a C stream with specified mode
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	// added with C++11
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a C stream with specified mode
		open(_Str.c_str(), _Mode, _Prot);
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	// open a C stream with specified mode (old style)
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */

	void close()
		{	// close the C stream
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
		}

private:
	_Myfb _Filebuffer;	// the file buffer
	};

template<class _Elem,
	class _Traits> inline
	void swap(basic_ofstream<_Elem, _Traits>& _Left,
		basic_ofstream<_Elem, _Traits>& _Right)
	{	// swap _Left and _Right basic_ofstreams
	_Left.swap(_Right);
	}

		// CLASS TEMPLATE basic_fstream
template<class _Elem,
	class _Traits>
	class basic_fstream
		: public basic_iostream<_Elem, _Traits>
	{	// input/output stream associated with a C stream
public:
	typedef basic_iostream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	basic_fstream()
		: _Mybase(&_Filebuffer)
		{	// construct unopened
		}

	explicit basic_fstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	// construct with named file and specified mode
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: basic_fstream(_Str.c_str(), _Mode, _Prot)
		{	// construct with named file and specified mode
		}

	explicit basic_fstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: basic_fstream(_Str.c_str(), _Mode, _Prot)
		{	// construct with wide-named file -- EXTENSION
		}

	template<class _Path_ish = experimental::filesystem::path>
		explicit basic_fstream(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: basic_fstream(_Path.c_str(), _Mode, _Prot)
		{	// construct with path-named file
		}

 #if _HAS_CXX17
	template<int = 0,
		class _Path_ish = filesystem::path>
		explicit basic_fstream(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: basic_fstream(_Path.c_str(), _Mode, _Prot)
		{	// construct with path-named file
		}
 #endif /* _HAS_CXX17 */

 #ifdef _NATIVE_WCHAR_T_DEFINED
	explicit basic_fstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #endif /* _NATIVE_WCHAR_T_DEFINED */

	explicit basic_fstream(_Filet *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	// construct with specified C stream
		}

	basic_fstream(basic_fstream&& _Right)
		: _Mybase(&_Filebuffer)
		{	// construct by moving _Right
		_Assign_rv(_STD move(_Right));
		}

	basic_fstream& operator=(basic_fstream&& _Right)
		{	// move from _Right
		_Assign_rv(_STD move(_Right));
		return (*this);
		}

	void _Assign_rv(basic_fstream&& _Right)
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, worth moving
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(basic_fstream& _Right)
		{	// swap with _Right
		if (this != _STD addressof(_Right))
			{	// different, swap base and buffer
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_fstream(const basic_fstream&) = delete;
	basic_fstream& operator=(const basic_fstream&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	// added with C++11
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream -- EXTENSION
		open(_Str.c_str(), _Mode, _Prot);
		}

	template<class _Path_ish = experimental::filesystem::path>
		void open(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a path-named C stream
		open(_Path.c_str(), _Mode, _Prot);
		}

 #if _HAS_CXX17
	template<int = 0,
		class _Path_ish = filesystem::path>
		void open(const _Identity_t<_Path_ish>& _Path,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a path-named C stream
		open(_Path.c_str(), _Mode, _Prot);
		}
 #endif /* _HAS_CXX17 */

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	// open a wide-named C stream (old style) (in standard as const std::filesystem::path::value_type *)
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */

 #ifdef _NATIVE_WCHAR_T_DEFINED
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	// added with C++11
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	// open a wide-named C stream (old style) (in standard as const std::filesystem::path::value_type *)
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
 #endif /* _NATIVE_WCHAR_T_DEFINED */

	virtual __CLR_OR_THIS_CALL ~basic_fstream() _NOEXCEPT
		{	// destroy the object
		}

	_NODISCARD _Myfb *rdbuf() const
		{	// return pointer to file buffer
		return ((_Myfb *)&_Filebuffer);
		}

	_NODISCARD bool is_open() const
		{	// test if C stream has been opened
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a C stream with specified mode
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	// added with C++11
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	// open a C stream with specified mode
		open(_Str.c_str(), _Mode, _Prot);
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	// open a C stream with specified mode (old style)
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */

	void close()
		{	// close the C stream
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
	}

private:
	_Myfb _Filebuffer;	// the file buffer
	};

template<class _Elem,
	class _Traits> inline
	void swap(basic_fstream<_Elem, _Traits>& _Left,
		basic_fstream<_Elem, _Traits>& _Right)
	{	// swap _Left and _Right basic_fstreams
	_Left.swap(_Right);
	}
_STD_END

 #pragma pop_macro("new")
 _STL_RESTORE_CLANG_WARNINGS
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
#endif /* _FSTREAM_ */

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
